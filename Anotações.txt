Este curso Ã© uma continuaÃ§Ã£o do curso Git e GitHub: compartilhando e colaborando em projetos, entÃ£o nÃ³s vamos partir do ponto onde paramos nele.

Caso vocÃª nÃ£o tenha feito o curso anterior, serÃ¡ necessÃ¡rio clonar o repositÃ³rio do curso para que todo o histÃ³rico de commits exista em seu ambiente local. Para isso, acesse o repositÃ³rio do instrutor Rodrigo Ferreira e clique no botÃ£o â€œForkâ€. Isso criarÃ¡ uma cÃ³pia do repositÃ³rio em sua conta. Com isso, vocÃª pode executar o git clone informando o endereÃ§o do seu repositÃ³rio.

Agora vocÃª jÃ¡ estÃ¡ pronto(a) para continuar com esse curso.

Bons estudos!


===================================================================================================================

git log -> visualiza nossa lista de commits
            visualizamos o hash completo do commit, e sua posiÃ§Ã£o no histÃ³rico, incluindo a qual branch ele pertence



    Ao lado do hash do ultimo commit, temos (HEAD -> main, origin/main, origin/HEAD). O que isso significa?
        -> main Ã© o nome de um branch
        -> origin, jÃ¡ sabemos que Ã© o nosso repositÃ³rio remoto
        -> PORTANTO origin/main significa que esse commit tambÃ©m Ã© onde estÃ¡ o nosso branch main no repositÃ³rio remoto
        -> Agora, o "HEAD" e o "origin/HEAD", que significam a mesma coisa que "HEAD" no repositÃ³rio remoto,  referem-se ao estado atual no repositÃ³rio remoto


git log --oneline -> mostrando apenas os primeiros caracteres do hash e a mensagem do commit


git log -p ->  permite examinar o commit e suas alteraÃ§Ãµes, nÃ£o apenas sua mensagem, mas tambÃ©m seu conteÃºdo. ele mostrarÃ¡ um diff

git log --graph -> exibirÃ¡ uma linha do nosso log, Ã© mais Ãºtil quando falarmos um pouco sobre branches.


git log --pretty|
                | ---> SÃ£o sinÃ´nimos -> permite formatar a saÃ­da do git log
git log --format|

Ex: git log --format="%H %an"

Para saber mais formatos de saida ->
-> git log --help e digitar /pretty formats para pesquisar sobre essa opÃ§Ã£o


# Analisando um commit especÃ­fico
git log --oneline

git show {hash do commit} -> Ex: git show 2ad48c0

caso seja executado um git show sem o hash na frente, serÃ£o exibidos os detalhes do ultimo commit


PRÃ“XIMAS ALTERAÃ‡Ã•ES
Apos alterar um arquivos, ANTES de rodar um git add . podemos verificar as mudanÃ§as realizadas no cÃ³digo.
O objetivo Ã© visualizar todas as alteraÃ§Ãµes antes de prosseguir com o commit.

Para isso -> git diff
 -> Git compara o Ãºltimo commit com o estado atual do cÃ³digo por padrÃ£o

Podemos executar um git diff {hash do commit} para compara as diferenÃ§as entre um commit especifico e a versÃ£o atual(head atual)
Exemplo: git diff 5880fc1

Ã‰ possivel comprara entre dois commits distintos

Para analisar a diferenÃ§a entre esses dois commits especÃ­ficos

git diff, o commit mais antigo, "..", o commit mais novo -> Ex:: git diff 5880fc1..5bc160e

ao executar um git add . o git diff nÃ£o exibe mais nada

Ao realizar o commit e rodar git log --oneline podemos ver a diferenÃ§a

8563ec5 (HEAD -> main) Mudando o tÃ­tulo para portuguÃªs
237cada (origin/main, origin/HEAD) mudanÃ§as no titulo e gitignore

======================================================================================
Branch

Vamos clonar novamente o projeto e execurar algumas mudanÃ§as e commitar apartit desse novo clone e rodar um git push origin main
ApÃ³s vamos editar o mesmo arquivo na outra pasta 

Fizemos o commit, mas agora, quando formos fazer o git push origin main, o Git vai rejeitar esse push, dizendo que existem atualizaÃ§Ãµes feitas que ainda nÃ£o estÃ£o no cÃ³digo.

Isso Ã© um "problema" que jÃ¡ conhecemos antes, entÃ£o o que precisa ser feito? Primeiro, precisamos fazer um git pull. Com isso, ele vai trazer as alteraÃ§Ãµes e fazer o que ele chama de merge.


ENTENDENDO SOBRE Branch
Esse site mostra como o git funciona de forma grÃ¡fica
https://git-school.github.io/visualizing-git/


git branch -> retorna quantas branchs exixstem no nosso ptojeto

git branch nova-branch -> cria uma nova branch

git checkout nome-branch -> alterna entre branchs

git checkout -b nova-funcionalidade -> cria uma nova branch alterna para a nova branchs



AlÃ©m desse comando mais antigo, podemos utilizar o

git switch nome-branch -> alterna entre branchs

git switch -c nome-branch -> Cria uma nova branch

ApÃ³s adicionar as modificaÃ§Ãµes podemos executar um commit

Podemor alternar entre as branch

Na branch criada podemos executar um git push tendo como origin a nova branch criada

git push origin nova-funcionalidade

https://git-school.github.io/visualizing-git/




Se vocÃª conhece o git com certeza jÃ¡ usou o comando git checkout. As novas versÃµes do git mexeram nesse comando para deixar ele mais coerente. Na verdade o git checkout foi separado em dois comandos:
https://cursos.alura.com.br/extra/alura-mais/entenda-os-comandos-git-restore-e-switch-c99
- git restore
- git switch

O git checkout Ã© utilizado para trocar de branch ou restaurar working tree files
Esse comando foi dividido em dois

** git restore

git restore --source hash-commit arquivo-ou-pasta -> coloca arquivos ou pasta ou o projeto todo naquele commit desajado

Ex: 
git restore --source e04771386a8e08060f7ec247c73f655da3c6f003 . -> para o projeto todo

git restore --source e04771386a8e08060f7ec247c73f655da3c6f003 index.html -> para um arquivo

git switch master -> retorna a master
Nesse sentido ao rodar um git status vemos que existem alteraÃ§Ãµes para ser comitadas com a esxlusÃ£o das linhas 

para voltar para o ultimo commit basta digitar um git restore passando o nome do arquivo desejado.
Ex:git restore index.html

Se quizermos voltar para um commit especifico e salvar as mudanÃ§as atuais para staged (pronta para commitar)
git restore --staged --source=1849ea3 index.html


Para desfazer a aÃ§Ã£o anterior
git restore --staged index.html



UNINDO AS RAMIFICAÃ‡Ã•ES 


ApÃ³s realizar as modificaÃ§Ãµes na branch nova-funcionalidade e realizar o commit basta voltar na branch main e executar: 
	git merge nova-funcionalidade 
e o git vai levar a main para o mesmo local.
 
Como a branch nova-funcionalidade evoluiu sem que a mester tivesse alteraÃ§Ãµes estamos falando de  um merge fast forward


O que Ã© fast forward?
Acontece quando a branch nova-funcionalidade evoluiu na mesma linha, sem que a master tivesse novos commits.

EntÃ£o, na hora de fazer o merge, Ã© muito simples: nÃ£o precisamos criar nenhum novo commit; o Git entende tudo e sÃ³ move as coisas. Se queremos unir as coisas, a partir de agora, a branch principal estarÃ¡ no mesmo ponto que a nova-funcionalidade. Isso Ã© o chamado fast forward.


REALIZANDO COMMITS NAS DUAS BRANCHS COM ALTERAÃ‡Ã•ES DIFERENTES
ApÃ³s realizar alteraÃ§Ãµe nas duas branchs e commitar vamos voltar para a branch main e executar um git merge da nova funcionaliade

Com esses comandos, serÃ¡ aberto um editor que permite a alteraÃ§Ã£o da mensagem de commit de merge. No nosso caso, vamos deixar o commit como estÃ¡.

Como o editor Ã© o VI, basta executar :x para salvar e sair. Ao final, teremos um novo commit criado. Se executarmos o comando git log --graph, podemos observar o que acontece na main.

Nesse caso temos um MERGE COMMIT


AJUSTES FINAIS

Para finalizar, vamos executar o comando git push origin main para atualizar a main com todo o trabalho novo. 

Em seguida, removeremos a branch nova-funcionalidade com git branch -d, para manter o projeto limpo e sem excesso de branches: 
git branch -d nova-funcionalidade

Ainda podemos remover a branch nova-funcionalidade do repositÃ³rio remoto no GitHub. Para isso, executamos o seguinte comando:
git push origin :nova-funcionalidade

================================================================================================================================

git rebease

Cenario-> na branch main criamos alguns commits e depois executamos um git checkout -b para criar uma branch
Na main, relaizamos mais alguns commits e voltamos para a nova branch criada e executamos alguns commits

Agora queremos deslocar branch criada para o estado atual da branch master. Ou seja quermos que a nossa nova branch, criada recentemente seja, seja criada 
apartir do estado atual da main.

Para isso utilizamos o rebase

Na branch criada vamos executar o comando 

git rebase main

Ele pegará o primeiro commit e tentar adicionar antes do commit nova-funcionalidade. Pegará o próximo commit, que é o último da main, 
e tentar adicionar antes do commit nova-funcionalidade. Após isso, pega todos os commits da nova-funcionalidade e aplica depois do 
último da main.

Se estamos na nova-funcionalidade e tentamos fazer o rebase com a main, ele vai alterar o branch para ir para a main. Depois da main, 
ele vai aplicando cada um dos commits da nova-funcionalidade. Isso é feito commit por commit, porque se tiver algum conflito em algum 
dos commits, vamos resolvendo um a um. Dessa forma, conseguimos reescrever a história.

Após 

git push origin main

git push origin nova-funcionalidade

git switch main

git merge nova-funcionalidade

git push origin main

asd

========================================================================================================================================

Estando na branch criada para nova funcionalidade, estamos desenvolvendo nosso trabalho e de repente surge uma demanda urgente para resolver.

Nesse caso, antes de resolver essa nova demanda temos que engavetar essa modificações que ainda não foram commitadas para continuar depois. Não podemos criar um commit agora porque nosso projeto está em um estado inválido. Além disso, se executarmos um git status, temos modificações. Portanto, não podemos começar a trabalhar em outra coisa e ir para outro branch, porque o arquivo app.js está modificado

Para isso vamos excutar um 

git stash

É uma pilha

o comando git stash, ele vai pegar tudo o que está no nosso estado atual e estocar. Ele vai guardar para que possamos recuperá-lo depois. 

Terminanos a noss demanda urgente e queremos voltar para as nosso trabalho, executamos

git stash pop
além de aplicar o item da stash, ele também o remove de lá. Esse comando, sem nenhum parâmetro extra, vai aplicar o último item adicionado à stash, mas nós também podemos informar um índice para ele, como git stash pop 1.

git stash list -> exibe todas as modificações que estã na pilha do stash

git stash clear -> limpa stash

git stash push -m "Movendo chamada de função" -> acresenta uma descrição ao nosso stash

git stash apply indice -> permite escolher qual stash queremos aplicar neste momento, Se ouver duas ou mais modificações referentes ao mesmo arquivo, podemos ter problemas de conflitos. 
        esse comando não remove o item da stash, ou seja, se após executar o comando git stash apply 1 você executar git stash list, o item referente ao índice 1 continuará na stash.

Drop
O git stash drop funciona exatamente como o pop, mas com uma simples diferença: ele apenas remove o item da stash, sem aplicá-lo em nosso repositório. Dessa forma, git stash drop remove o último item adicionado à stash, enquanto o git stash drop 1 remove da stash o item com índice 1.

git restore . -> restaura todos os arquivos do diretório atual para o estado do ultimo commit
 -> substitui o git checkout --
 
com git restore --staged app.js, não desfazemos a alteração, mas retornamos ao estado anterior. Agora, é como se não tivéssemos feito o git add.

suponha que queremos mover nosso index.html para o estado que estava quando fizemos o Merge branch 'nova-funcionalidade' into main.

git restore --source = 5081a55bc92af2917c8519f16a7412b86ba3b1c2 index.html

Podemos modificar o arquivo a partir daquele estado e adicionar um novo commit, se quisermos. mas, se quisermos apenas visualizar o arquivo e entender como ele estava naquele estado, podemos desfazer esse trabalho, ou seja, restaurar para o estado normal dele com o git restore index.html, que é equivalente a fazer --source = head.

git branch -d movendo-detalhes


==========================================================================================
git tag

É utilizada para marcar um ponto ( um commit). Isso pode ser usado versão do nosso sistema. Serve de save point

executando o git log podemos verificar a nossa arvore de commit e escolher qual o commit queremos adicionar a tags.

Executando o comando 

git tag nome_da_tag -> cria a tag no HEAD

git tag nome_da_tag código_do_commit -> cria tag em outro commit 

git tag -> exibe todas as tags

git push orign nome_tag -> envia para p repositório remoto uma tag especofíca

git push orign --tags, que fará o push de todas as tags.

** é necessario enviar as tags para que elas apareçam no git hub

Conferindo as tags no GitHub

-> coluna da esquerda, na seção "Relaeases" (Lançamentos)

-> permite o download do projeto em arquivos compactados, tanto no formato .zip, quanto no .tar.gz

